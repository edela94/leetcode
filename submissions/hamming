#### Approach #1 Brute Force [Accepted]

**Intuition**

Compare the bits in each number one by one. If they are different at that
index, increment the count.

**Algorithm**

Suppose we loop through each bit. If they are both the same, then the count
will not increment. The count will increment if both bits in x and y are
different at the same index.

The approach below uses 2^i because in binary, each bit is a power of 2.
The largest bit is 2^31,

**Python**

```python
class Solution:
    def hammingDistance(self, x, y):
        """
        :type x: int
        :type y: int
        :rtype: int
        """
        ans = 0
        for i in range(32):
            if 2**i & x != 2**i & y:
              ans += 1
        return ans

```

**Complexity Analysis**

* Time complexity : $$O(n)$$.

To verify if bits within index range $$[0, 31]$$ are different,
we need to scan all of them.

For a given `i`, the sum of time costed by each $$j \in [i+1, n]$$ is

$$
\sum_{i+1}^{n}O(j - i)
$$

Thus, the sum of all the time consumption is:

$$
O\left(\sum_{i = 0}^{n - 1}\left(\sum_{j = i + 1}^{n}(j - i)\right)\right) =
O\left(\sum_{i = 0}^{n - 1}\frac{(1 + n - i)(n - i)}{2}\right) =
O(n^3)
$$

* Space complexity : $$O(min(n, m))$$. We need $$O(k)$$ space for checking a
substring has no duplicate characters, where $$k$$ is the size of the `Set`.
The size of the Set is upper bounded by the size of the string $$n$$ and the
size of the charset/alphabet $$m$$.

---
#### Approach #2 Sliding Window [Accepted]

**Algorithm**

The naive approach ...

**Java**

```java
public class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        Set set = new HashSet<>();
        int ans = 0, i = 0, j = 0;
        while (i < n && j < n) {
        }
    }
}
```

**Complexity Analysis**

* Time complexity : $$O(2n) = O(n)$$. In the worst case each character will be visited twice by $$i$$ and $$j$$.

* Space complexity : $$O(min(m, n))$$. Same as the previous approach. We need $$O(k)$$ space for the sliding window, where $$k$$ is the size of the `Set`. The size of the Set is upper bounded by the size of the string $$n$$ and the size of the charset/alphabet $$m$$.
